/*
    Run the test functions discovered in the source.
    Generated by __GEN_SCRIPT_NAME__ on __GEN_DATE__
*/
#include <stdio.h>
#include <stddef.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <stdbool.h>
#include <argp.h>
#include <fnmatch.h>

#define TAB "    "

#define FILE_NAME_LENGTH __FILE_NAME_LENGTH__
#define FUNCTIONS_NAME_LENGTH __FUNCTIONS_NAME_LENGTH__

// --- FUNCTION TABLES TYPES ---

struct test_func_s
{
    const char name[FUNCTIONS_NAME_LENGTH + 1];
    const char *(*test_func)();
};

struct test_file_s
{
    const char name[FILE_NAME_LENGTH + 1];
    const struct test_func_s *funcstable;
};

// --- DISCOVERED TEST FUNCTIONS ---
__FILES_LIST__
// __FILENAME__

__DISCOVERED_TEST_FUNCTIONS__

static const struct test_func_s __FUNCTABLE_NAME__[] = {
    __DISCOVERED_FUNCS_TABLE__{"", NULL}};

__FILES_LIST__
// --- DISCOVERED FILES TABLE ---

static const struct test_file_s filetable[] = {
    __DISCOVERED_FILES_TABLE__{"", NULL}};

// --- TESTING ---

struct test_result_s
{
    bool success;
    bool is_fail_anomalous;
    size_t msg_len;
};

// run the test
static void child_run_test(const char *(*test_func)(), int report_pipe)
{
    // execute test
    const char *result = (*test_func)();

    // write the result to parent
    struct test_result_s result_struct = {
        .success = (result == NULL),
        .is_fail_anomalous = false,
        .msg_len = (result != NULL) ? (strlen(result) + 1) : 0};
    // writing to pipe
    write(report_pipe, &result_struct, sizeof(result_struct));
    if (result != NULL)
        write(report_pipe, result, strlen(result) + 1);
    // closing the pipe
    close(report_pipe);
}

static const char UNSPECIFIED_ANOMALOUS_FAIL[] = "ANOMALOUS: Test failed anomalously without reporting";
static const char STREAM_REDIRECTING_ANOMALOUS_FAIL[] = "ANOMALOUS: failed to redirect default output streams";

// fork to run a test
// it separate the addresspace to guarantee it cannot alter global addresspace
// return the test result
static struct complete_test_result_s
{
    struct test_result_s result;
    char const *result_msg;
    int out_pipe;
} fork_test(const char *(*test_func)())
{
    // creating a pipe for child->parent communication

    int report_pipe[2]; // pipe for reporting the errors
    if (pipe(report_pipe) < 0)
    {
        fprintf(stderr, "Error on creating the report pipe!\n");
        exit(1);
    }

    int out_pipe[2]; // pipe for the eventual output of the test
    if (pipe(out_pipe) < 0)
    {
        fprintf(stderr, "Error on creating the output pipe!\n");
        exit(1);
    }

    // flushing pipes
    fflush(stdout);
    fflush(stderr);

    // forking

    int pid; // process id
    if ((pid = fork()) < 0)
    {
        fprintf(stderr, "Error on forking the process!\n");
        exit(1);
    }
    // now we split based on pid
    if (pid)
    {
        // parent process

        // we don't need to write anything, so i close the pipes
        close(report_pipe[1]);
        close(out_pipe[1]);

        // read back the result
        struct test_result_s result;
        ssize_t bytes = read(report_pipe[0], &result, sizeof(result));
        if (bytes < 0)
        {
            fprintf(stderr, "Error on reading results from pipe!\n");
            exit(1);
        }
        else if ((size_t)bytes < sizeof(result))
        {
            // Anomalous termination of child process
            result.success = false;
            result.is_fail_anomalous = true;
            result.msg_len = 0; // do not try to read, it's empty
        }

        // read the eventual result message
        char const *result_msg = NULL;
        if (result.msg_len)
        {
            char *result_msg_buffer = malloc(result.msg_len);
            if (result_msg_buffer == NULL)
            {
                fprintf(stderr, "Failed to malloc space for test result message\n");
                exit(1);
            }
            ssize_t readed_bytes = read(report_pipe[0], result_msg_buffer, result.msg_len);
            if (readed_bytes < 0)
            {
                fprintf(stderr, "Error on reading message from pipe!\n");
                exit(1);
            }
            else if ((size_t)readed_bytes < result.msg_len)
            {
                // strange string termination, this should never happen
                result_msg_buffer[readed_bytes] = '\0'; // terminate the string
            }
            result_msg = result_msg_buffer;
        }

        // close the pipe
        close(report_pipe[0]);

        if (result.is_fail_anomalous && result.msg_len == 0)
        {
            result.msg_len = strlen(UNSPECIFIED_ANOMALOUS_FAIL);
            result_msg = UNSPECIFIED_ANOMALOUS_FAIL;
        }

        return (struct complete_test_result_s){.result = result,
                                               .result_msg = result_msg,
                                               .out_pipe = out_pipe[0]};
    }
    else
    {
        // child process

        // we won't read anything, so i close the pipes
        close(report_pipe[0]);
        close(out_pipe[0]);

        // redirectiong stout and stdint to pipe
        if (dup2(out_pipe[1], STDOUT_FILENO) < 0 ||
            dup2(out_pipe[1], STDERR_FILENO) < 0)
        {
            struct test_result_s result = {
                .success = false,
                .is_fail_anomalous = false,
                .msg_len = strlen(STREAM_REDIRECTING_ANOMALOUS_FAIL)};
            write(report_pipe[1], &result, sizeof(result));
            write(report_pipe[1], STREAM_REDIRECTING_ANOMALOUS_FAIL, strlen(STREAM_REDIRECTING_ANOMALOUS_FAIL) + 1);

            _exit(1); // exit without flushing streams
        }

        // run the test
        child_run_test(test_func, report_pipe[1]);

        // flush the out_stream
        close(out_pipe[1]);

        // exit normally
        exit(0);
    }
}

#ifdef __GNUC__
__attribute__((const))
#endif
static size_t
count_tests()
{
    size_t count = 0;
    for (size_t i = 0; filetable[i].funcstable != NULL; i++)
        for (size_t j = 0; filetable[i].funcstable[j].test_func != NULL; j++)
            count++;
    return count;
}

enum out_report_e
{
    OUT_REPORT_ALWAYS,
    OUT_REPORT_FAIL,
    OUT_REPORT_ANOMALOUS_FAIL,
    OUT_REPORT_NEVER = 0
};

// contain the result of the argument parsing
struct parsed_args_s
{
    const char *filename; // if not null, run only tests from files mathing filename
    const char *testname; // if not null, run only tests matching testname

    bool dry_run;                 // if true, do not run any test, only list them
    bool critical_fail;           // if true, close after the first fail
    enum out_report_e out_report; // set if report test output (if present)
};

static size_t all_tests(FILE *out, struct parsed_args_s options)
{
    size_t failed_tests = 0;
    size_t runned_tests = 0;
    size_t const num_tests = count_tests();

    bool continue_running = true;

    // preparing string for printing
    int const test_num_string_maxlen = snprintf(NULL, 0, "%lu", num_tests);

    fprintf(out, "Running tests...\n\n");
    // looping on all discovered file
    for (size_t i = 0; filetable[i].funcstable != NULL && continue_running; i++)
    {
        if (options.filename != NULL && fnmatch(options.filename, filetable[i].name, FNM_PATHNAME | FNM_PERIOD) != 0)
        {
            fprintf(out, "Skipping tests from file '%s'\n\n", filetable[i].name);
            continue;
        }

        fprintf(out, "Running tests from file '%s':\n", filetable[i].name);
        for (size_t j = 0; filetable[i].funcstable[j].test_func != NULL && continue_running; j++)
        {
            // filename and progress
            fprintf(out, TAB "[%*lu/%*lu/%*lu] %-*s -> ",
                    test_num_string_maxlen, failed_tests,
                    test_num_string_maxlen, runned_tests,
                    test_num_string_maxlen, num_tests,
                    FUNCTIONS_NAME_LENGTH, filetable[i].funcstable[j].name);

            if (options.testname != NULL && fnmatch(options.testname, filetable[i].funcstable[j].name, 0) != 0)
            {
                fprintf(out, "[SKIP]\n");
                continue;
            }
            if (options.dry_run)
            {
                fprintf(out, "[    ]\n");
                continue;
            }

            // run test
            struct complete_test_result_s result = fork_test(filetable[i].funcstable[j].test_func);
            runned_tests++;

            // print result
            if (result.result.success)
                fprintf(out, "[OKAY]\n");
            else
            {
                fprintf(out, "[FAIL]\n" TAB TAB "Fail message is: %s\n", result.result_msg);
                failed_tests++;
            }

            // checking if we have to report the output
            if (options.out_report && ((options.out_report == OUT_REPORT_ALWAYS) ||
                                       (options.out_report == OUT_REPORT_FAIL && !result.result.success) ||
                                       (options.out_report == OUT_REPORT_ANOMALOUS_FAIL && !result.result.success && result.result.is_fail_anomalous)))
            {
                char ch;
                if (read(result.out_pipe, &ch, 1) == 1) // if output pipe is not empty
                {
                    fprintf(out, TAB TAB "Output of the test on <stdout> and <stderr> was:\n" TAB TAB TAB);

                    do
                        if (ch != '\n')
                            fwrite(&ch, 1, 1, out);
                        else
                            fprintf(out, "\n" TAB TAB TAB); // tabulating output
                    while (read(result.out_pipe, &ch, 1) == 1);

                    fprintf(out, "\n");
                }
            }
            else
                fprintf(out, TAB TAB "No output of the test on <stdout> and <stderr>\n");

            if (options.critical_fail && !result.result.success)
                continue_running = false; // close at the fist fail
        }
        fprintf(out, "\n");
    }

    fprintf(out, "Out of %lu tests %lu runned %lu failed\n", num_tests, runned_tests, failed_tests);

    return failed_tests;
}

// --- ARGUMENT PARSING ---

const char *argp_program_version = "__GEN_SCRIPT_VERSION__";
const char *argp_program_bug_address = "<zannabianca199712@gmail.com>";

static const struct parsed_args_s ARGS_DEFAULT = {
    .filename = NULL,
    .testname = NULL,
    .dry_run = false,
    .critical_fail = false,
    .out_report = OUT_REPORT_ANOMALOUS_FAIL};

// contains all the options the program can receive
static const struct argp_option ARGUMENT_PARSER_OPTIONS[] = {
    {"filename", 'f', "FILENAME", 0, "Run only test included from files matching  \"FILENAME\"", 0},
    {"testname", 't', "TESTNAME", 0, "Run only test matching \"TESTNAME\"", 0},
    {"dry-run", 'd', NULL, 0, "Do not run any test, only list them", 0},
    {"critical-fails", 'c', NULL, 0, "Stop after the first test failed", 0},
    {"report-output", 'r', "REPORT-OUTPUT", 0, "What to do when a test write to <stdout> or <stderr>", 0},
    {"REPORT-OUTPUT:", 0, NULL, OPTION_DOC, "REPORT-OUTPUT should be one of the following (case insensitive):\n"
                                            "- ALWAYS: always report\n"
                                            "- FAILS: report only if test failed\n"
                                            "- ANOMALOUS-FAILS: report only if test closed without returning (default)\n"
                                            "- NEVER: never report\n",
     0},
    {0}};

static error_t argument_parser(int key, char *arg, struct argp_state *state);

static const struct argp ARGUMENT_PARSER_SETUP = {
    .options = ARGUMENT_PARSER_OPTIONS,
    .parser = &argument_parser,
    .args_doc = NULL,
    .doc = "Run the test functions discovered in the source.\n"
           "Generated by __GEN_SCRIPT_NAME__ on __GEN_DATE__\n"};

// parse an option
static error_t argument_parser(int key, char *arg, struct argp_state *state)
{
    struct parsed_args_s *argument_parsed = (struct parsed_args_s *)state->input;
    switch (key)
    {
    case 'f':
        argument_parsed->filename = arg;
        return 0;
    case 't':
        argument_parsed->testname = arg;
        return 0;

    case 'd':
        argument_parsed->dry_run = true;
        return 0;
    case 'c':
        argument_parsed->critical_fail = true;
        return 0;
    case 'r':
        if (strcasecmp(arg, "ALWAYS") == 0)
            argument_parsed->out_report = OUT_REPORT_ALWAYS;
        else if (strcasecmp(arg, "FAILS") == 0)
            argument_parsed->out_report = OUT_REPORT_FAIL;
        else if (strcasecmp(arg, "ANOMALOUS-FAILS") == 0)
            argument_parsed->out_report = OUT_REPORT_ANOMALOUS_FAIL;
        else if (strcasecmp(arg, "NEVER") == 0)
            argument_parsed->out_report = OUT_REPORT_NEVER;
        else
            argp_error(state, "\"%s\" is not a valid value for REPORT-OUTPUT\n", arg);
        return 0;

    default:
        return ARGP_ERR_UNKNOWN;
    }
    return 0;
}

int main(int argc, char *argv[])
{
    struct parsed_args_s parsed_args = ARGS_DEFAULT;
    argp_parse(&ARGUMENT_PARSER_SETUP, argc, argv, 0, NULL, &parsed_args);

    // run all matching tests
    return all_tests(stdout, parsed_args);
}