#!/bin/env python3
"""
    Auto generate a basic makefile, with source exploration and catalog update
"""

from argparse import ArgumentParser, FileType
from datetime import datetime
from itertools import chain
from pathlib import Path
import subprocess
from sys import stderr
from typing import Dict, Set, Tuple
from subprocess import run


MAKEFILE_SKEL = """# GENERATED ON {date:%Y-%m-%d %H:%M} by {configure_name}

# --- PARAMETERS ---

# compilation directories
SOURCE_DIR := {source_dir}
DEBUG_DIR := {debug_dir}
RELEASE_DIR := {release_dir}

# output binaries names
BINARY_NAME := {binary_name}
TEST_BINARY_NAME := {test_binary_name}

# entry point 
MAIN_NAME := {main_name}

# c compiler setup
CC := gcc
CFLAGS := -std=c99 -Wall -Wextra -Wpedantic
CDEBUG_FLAGS := -O0 -DDEBUG -DCHECK_ERRORLEVELS_VALIDITY -DCHECK_LOGTARGET_PTR -DCHECK_CONTEXT_CHILDS
CRELEASE_FLAGS := -Werror -O3
LDFLAGS := 

# system commands
RM := rm -rf
MKDIR := mkdir -p

# configure script
CONFIGURE_SCRIPT := {configure_name}

# catalog script
CATALOG_SCRIPT := {catalog_script}

# --- MAKE OPTIONS ---

# defaulting to debug build
ifndef BUILD
    BUILD := debug
endif

# adding debug flags
ifeq ($(BUILD), debug)
    BUILD_DIR := $(DEBUG_DIR)
    CFLAGS += $(CDEBUG_FLAGS)
else ifeq ($(BUILD), release)
    BUILD_DIR := $(RELEASE_DIR)
    CFLAGS += $(CRELEASE_FLAGS)
else
    $(error BUILD flag can only have the value "debug" or "release")
endif

# --- DISCOVERED SOURCES AND OBJECTS ---

# list of sources
SOURCES := {sources}
TEST_SOURCES := {test_sources}

# lists of object files needed
OBJECTS := {objects}
MAIN_OBJ := {main_obj}
TEST_OBJECTS := {test_objects}

# list of catalogs to generate
CATALOG_FILES := {catalog_files}
CATALOG_HEADERS := {catalog_header}

# binaries
BINARY := $(BUILD_DIR)/$(BINARY_NAME)
TEST_BINARY := $(BUILD_DIR)/$(TEST_BINARY_NAME)

# --- OTHER ---

# makefile name
MAKEFILE_NAME := $(abspath $(lastword $(MAKEFILE_LIST)))

# configure script call
CONFIGURE_ARGS := -source_dir $(SOURCE_DIR) -debug_dir $(DEBUG_DIR) -release_dir $(RELEASE_DIR) \\
                  -binary_name $(BINARY_NAME) -test_binary_name $(TEST_BINARY_NAME) -main_name $(MAIN_NAME) \\
                  -catalog_script $(CATALOG_SCRIPT)

# delete predefined rules
.SUFFIXES:

# --- PHONY TARGETS ---

.PHONY: all build test test_build catalogs clean

all: catalogs test build $(MAKEFILE_NAME)

build: $(BINARY) $(MAKEFILE_NAME)

test: test_build $(MAKEFILE_NAME)
\t$(TEST_BINARY) $(TEST_ARGS)

test_build: $(TEST_BINARY) $(MAKEFILE_NAME)

catalogs: $(CATALOG_HEADERS)

clean: $(MAKEFILE_NAME)
\t$(RM) $(BUILD_DIR)

# --- LINKER TARGETS ---

$(BINARY): $(MAIN_OBJ) $(OBJECTS) $(MAKEFILE_NAME) | $(dir $(BINARY))
\t$(CC) $(LDFLAGS) $(MAIN_OBJ) $(OBJECTS) $< -o $@

$(TEST_BINARY): $(OBJECTS) $(TEST_OBJECTS) $(MAKEFILE_NAME) | $(dir $(TEST_BINARY))
\t$(CC) $(LDFLAGS) $(OBJECTS) $(TEST_OBJECTS) -o  $@

# --- COMPILE RULES ---

{compile_rules}

# --- COMPILE TEST RULES ---

{compile_test_rules}

# --- CATALOG GENERATION RULES ---

{catalog_rules}

# --- DIRECTORY CREATION ---

{directory_rules}

# --- MAKEFILE REGENERATION ---

$(MAKEFILE_NAME): $(CONFIGURE_SCRIPT)
\t$(CONFIGURE_SCRIPT) $(CONFIGURE_ARGS) $(MAKEFILE_NAME)
"""

PARAMETER: Dict[str, Tuple[str, str]] = {
    "source_dir": ("src", "The directory containing the source files"),
    "debug_dir": ("debug", "The directory where the debug versions of the program will be built"),
    "release_dir": ("release", "The directory where the release versions of the program will be built"),
    "binary_name": ("ic4", "The name of the finished binary"),
    "test_binary_name": ("ic4_test", "The name of the test binary"),
    "main_name": ("main.c", "The name of the file containing the entry point"),
    "catalog_script": ("misc/messages/make_catalog.py", "Where the catalog script is located")
}

TEST_PREFIX = "test_"

DIRECTORY_RULE = "$(BUILD_DIR)/{dirname}:\n\t$(MKDIR) $@"

CATALOG_RULE = "$(BUILD_DIR)/{cat_header_name}: $(SOURCE_DIR)/{cat_name} $(MAKEFILE_NAME) $(SOURCE_DIR)/$(CATALOG_SCRIPT) | $(BUILD_DIR)/{cat_dir}\n\t$(SOURCE_DIR)/$(CATALOG_SCRIPT) $< -o $@"


def examine_source_tree(source_dir: str) -> Tuple[Set[Path], Set[Path], Set[Path], Set[Path], Set[Path]]:
    """Search source_dir and it's subdirectories for file of the type *.c, test_*.c, *.h, *.cat"""
    source_dir: Path = Path(source_dir)

    all_source_files = set(source_dir.glob("**/*.c"))
    test_source_files = set(
        x for x in all_source_files if x.stem.lower().startswith(TEST_PREFIX))
    source_files = all_source_files.difference(test_source_files)

    headers_files = set(source_dir.glob("**/*.h"))
    catalog_files = set(source_dir.glob("**/*.cat"))

    # making all the path relative
    source_files, test_source_files, headers_files, catalog_files = (
        set(p.relative_to(source_dir) for p in paths)
        for paths in (source_files, test_source_files, headers_files, catalog_files)
    )

    # collecting interesting directories
    directories = set(p.parent for p in chain(
        source_files, test_source_files, headers_files, catalog_files))

    return (source_files, test_source_files, headers_files, catalog_files, directories)


def make_compile_rule(source: Path, source_dir: Path) -> str:
    """Create a compile rule for source"""
    # first we get all the includes
    p = subprocess.Popen(["gcc", "-MM", "-MG", str(source_dir / source)],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    output, output_err = p.communicate()

    if output_err:
        print(f"Error while reading includes of {source}")
        print(output_err.decode("utf-8"), file=stderr)
        exit(1)

    files =  [Path(p) for p in output.decode("utf-8").split(":", maxsplit=1)[1].replace("\\\n", "").split()]

    catalog_files = [(source.parent / p) for p in files if p.name.endswith(".cat.h")]
    catalog_dirs = set(p.parent for p in catalog_files)

    source_files = [p.resolve().relative_to(source_dir.absolute()) for p in files if not p.name.endswith(".cat.h")]

    rule = f"""$(BUILD_DIR)/{source.with_suffix(".o")}: \\
    {" ".join(f"$(SOURCE_DIR)/{str(p)}" for p in source_files)} \\
    {" ".join(f"$(BUILD_DIR)/{str(p)}" for p in catalog_files)} $(MAKEFILE_NAME) | \\
    $(BUILD_DIR)/{str(source.parent)}
\t$(CC) $(CFLAGS) {" ".join(f"-I$(BUILD_DIR)/{str(p)}" for p in catalog_dirs)} -c $< -o $@"""

    return rule




def get_argparser() -> ArgumentParser:
    """Prepare a argument parser for cli invocation"""
    parser = ArgumentParser(description=__doc__)

    parser.add_argument("outputfile", nargs="?", type=FileType("w"), default=open("Makefile", "w"),
                        help="The output Makefile. If absent defaults to \"Makefile\"")

    for par_name, (par_default, par_descr) in PARAMETER.items():
        parser.add_argument(f"-{par_name}", type=str,
                            default=par_default, help=par_descr)

    return parser


def main(argv):
    parsed_args = get_argparser().parse_args(argv[1:])

    source_files, test_source_files, headers_files, catalog_files, directories = examine_source_tree(
        parsed_args.source_dir)

    # remove main from source files
    source_files.discard(Path(parsed_args.main_name))

    parameters = {name: vars(parsed_args)[name] for name in PARAMETER}
    parameters["date"] = datetime.now()
    parameters["configure_name"] = argv[0]

    parameters["sources"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in source_files)
    parameters["test_sources"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in test_source_files)

    parameters["objects"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.o'))}" for p in source_files)
    parameters["main_obj"] = f"$(BUILD_DIR)/{str(Path(parsed_args.main_name).with_suffix('.o'))}"
    parameters["test_objects"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.o'))}" for p in test_source_files)

    parameters["catalog_files"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in catalog_files)
    parameters["catalog_header"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.cat.h'))}" for p in catalog_files)

    parameters["compile_rules"] = make_compile_rule(Path(parsed_args.main_name), Path(parsed_args.source_dir))+"\n\n" + "\n\n".join(
        make_compile_rule(p, Path(parsed_args.source_dir)) for p in source_files)
    parameters["compile_test_rules"] = "\n\n".join(
        make_compile_rule(p, Path(parsed_args.source_dir)) for p in test_source_files)
    parameters["catalog_rules"] = "\n\n".join(
        CATALOG_RULE.format(cat_name=str(p), cat_header_name=str(p.with_suffix(".cat.h")), cat_dir=str(p.parent)) for p in catalog_files)
    parameters["directory_rules"] = "\n\n".join(
        DIRECTORY_RULE.format(dirname=str(p)) for p in directories)

    print(MAKEFILE_SKEL.format(**parameters), file=parsed_args.outputfile)
    parsed_args.outputfile.close()


if __name__ == "__main__":
    from sys import argv
    main(argv)
