#!/bin/env python3
"""
    Auto generate a basic makefile, with source exploration and catalog update
"""

from argparse import ArgumentParser, FileType
from datetime import datetime
from itertools import chain
from pathlib import Path
import subprocess
from sys import stderr
from typing import Dict, Set, Tuple


DIRECTORY_RULE = "$(BUILD_DIR)/{dirname}/:\n\t$(MKDIR) $@"

CATALOG_RULE = "$(BUILD_DIR)/{cat_header_name}: $(SOURCE_DIR)/{cat_name} $(MAKEFILE_NAME) $(SOURCE_DIR)/$(CATALOG_SCRIPT) | $(dir $(BUILD_DIR)/{cat_header_name})\n\t$(SOURCE_DIR)/$(CATALOG_SCRIPT) $< -o $@"


PARAMETER: Dict[str, Tuple[str, str]] = {
    "source_dir": ("src", "The directory containing the source files"),
    "debug_dir": ("debug", "The directory where the debug versions of the program will be built"),
    "release_dir": ("release", "The directory where the release versions of the program will be built"),
    "binary_name": ("ic4", "The name of the finished binary"),
    "main_name": ("main.c", "The name of the file containing the entry point"),
    "test_prefix": ("test_", "The prefix identifing what files are tests and what aren't"),
    "test_binary_name": ("ic4_test", "The name of the test binary"),
    "test_main_name": ("test_main.c", "The name of the generated file containing the test entry point"),
    "catalog_script": ("misc/catalog.py", "Where the catalog script is located"),
    "test_discovery_script": ("misc/test_discovery.py", "Where the test discovery script is located"),
}

def examine_source_tree(source_dir: str, test_prefix:str) -> Tuple[Set[Path], Set[Path], Set[Path], Set[Path], Set[Path]]:
    """Search source_dir and it's subdirectories for file of the type *.c, test_*.c, *.h, *.cat"""
    source_dir: Path = Path(source_dir)

    all_source_files = set(source_dir.glob("**/*.c"))
    test_source_files = set(
        x for x in all_source_files if x.stem.lower().startswith(test_prefix))
    source_files = all_source_files.difference(test_source_files)

    headers_files = set(source_dir.glob("**/*.h"))
    catalog_files = set(source_dir.glob("**/*.cat"))

    # making all the path relative
    source_files, test_source_files, headers_files, catalog_files = (
        set(p.relative_to(source_dir) for p in paths)
        for paths in (source_files, test_source_files, headers_files, catalog_files)
    )

    # collecting interesting directories
    directories = set(p.parent for p in chain(
        source_files, test_source_files, headers_files, catalog_files))

    return (source_files, test_source_files, headers_files, catalog_files, directories)


def make_compile_rule(source: Path, source_dir: Path) -> str:
    """Create a compile rule for source"""
    # first we get all the includes
    p = subprocess.Popen(["gcc", "-MM", "-MG", str(source_dir / source)],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    output, output_err = p.communicate()

    if output_err:
        print(f"Error while reading includes of {source}")
        print(output_err.decode("utf-8"), file=stderr)
        exit(1)

    files =  [Path(p) for p in output.decode("utf-8").split(":", maxsplit=1)[1].replace("\\\n", "").split()]

    catalog_files = [(source.parent / p) for p in files if p.name.endswith(".cat.h")]
    catalog_dirs = set(p.parent for p in catalog_files)

    source_files = [p.resolve().relative_to(source_dir.absolute()) for p in files if not p.name.endswith(".cat.h")]

    rule = f"""$(BUILD_DIR)/{source.with_suffix(".o")}: \\
    {" ".join(f"$(SOURCE_DIR)/{str(p)}" for p in source_files)} \\
    {" ".join(f"$(BUILD_DIR)/{str(p)}" for p in catalog_files)} $(MAKEFILE_NAME) | \\
    $(dir $(BUILD_DIR)/{source.with_suffix(".o")})
\t$(CC) $(CFLAGS) {" ".join(f"-I$(BUILD_DIR)/{str(p)}" for p in catalog_dirs)} -c $< -o $@"""

    return rule




def get_argparser() -> ArgumentParser:
    """Prepare a argument parser for cli invocation"""
    parser = ArgumentParser(description=__doc__)

    parser.add_argument("outputfile", nargs="?", type=FileType("w"), default=open("Makefile", "w"),
                        help="The output Makefile. If absent defaults to \"Makefile\"")
    parser.add_argument("-mskel", nargs="?", type=FileType("r"), default=open("Makefile.skel", "r"),
                        help="The input Makefile skeleton. If absent defaults to \"Makefile.skel\"")

    for par_name, (par_default, par_descr) in PARAMETER.items():
        parser.add_argument(f"-{par_name}", type=str,
                            default=par_default, help=par_descr)

    return parser


def main(argv):
    parsed_args = get_argparser().parse_args(argv[1:])

    source_files, test_source_files, headers_files, catalog_files, directories = examine_source_tree(parsed_args.source_dir, parsed_args.test_prefix)

    # remove main from source files
    source_files.discard(Path(parsed_args.main_name))

    parameters = {name: vars(parsed_args)[name] for name in PARAMETER}
    parameters["date"] = datetime.now()
    parameters["configure_name"] = argv[0]
    parameters["makefile_skel"] = parsed_args.mskel.name

    parameters["sources"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in source_files)
    parameters["test_sources"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in test_source_files)

    parameters["objects"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.o'))}" for p in source_files)
    parameters["main_obj"] = f"$(BUILD_DIR)/{str(Path(parsed_args.main_name).with_suffix('.o'))}"
    parameters["test_objects"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.o'))}" for p in test_source_files)
    parameters["test_main_obj"] = f"$(BUILD_DIR)/{str(Path(parsed_args.test_main_name).with_suffix('.o'))}"

    parameters["catalog_files"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in catalog_files)
    parameters["catalog_header"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.cat.h'))}" for p in catalog_files)

    parameters["compile_rules"] = make_compile_rule(Path(parsed_args.main_name), Path(parsed_args.source_dir))+"\n\n" + "\n\n".join(
        make_compile_rule(p, Path(parsed_args.source_dir)) for p in source_files)
    parameters["compile_test_rules"] = "\n\n".join(
        make_compile_rule(p, Path(parsed_args.source_dir)) for p in test_source_files)
    parameters["catalog_rules"] = "\n\n".join(
        CATALOG_RULE.format(cat_name=str(p), cat_header_name=str(p.with_suffix(".cat.h"))) for p in catalog_files)
    parameters["directory_rules"] = "\n\n".join(
        DIRECTORY_RULE.format(dirname=str(p)) for p in directories)

    print(parsed_args.mskel.read().format(**parameters), file=parsed_args.outputfile)
    parsed_args.outputfile.close()


if __name__ == "__main__":
    from sys import argv
    main(argv)
