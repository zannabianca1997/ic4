#!/bin/env python3
"""
    Auto generate a basic makefile, with source exploration and catalog update 
"""

from argparse import ArgumentParser, FileType
from datetime import datetime
from difflib import HtmlDiff
from itertools import chain
from pathlib import Path
import subprocess
from sys import stderr, stdout
from typing import Dict, List, Set, Tuple


DIRECTORY_RULE = "$(BUILD_DIR)/{dirname}/:\n\t$(MKDIR) $@"

CATALOG_RULE = "$(BUILD_DIR)/{cat_header_name}: $(SOURCE_DIR)/{cat_name} $(CATALOG_SCRIPT) | $(dir $(BUILD_DIR)/{cat_header_name})\n\t$(CATALOG_SCRIPT) $< -o $@"


PARAMETER: Dict[str, Tuple[str, str]] = {
    "source_dir": ("src", "The directory containing the source files"),
    "debug_dir": ("debug", "The directory where the debug versions of the program will be built"),
    "release_dir": ("release", "The directory where the release versions of the program will be built"),
    "binary_name": ("ic4", "The name of the finished binary"),
    "main_name": ("main.c", "The name of the file containing the entry point"),
    "test_prefix": ("test_", "The prefix identifing what files are tests and what aren't"),
    "test_binary_name": ("ic4_test", "The name of the test binary"),
    "test_main_name": ("test_main.c", "The name of the generated file containing the test entry point"),
    "catalog_script": ("utils/catalog.py", "Where the catalog script is located"),
    "test_discovery_script": ("utils/test_discovery.py", "Where the test discovery script is located"),
    "test_main_skel": ("utils/test_main.c.skel", "File from where the test main will be generated")
}


def examine_source_tree(source_dir: str, test_prefix: str) -> Tuple[Set[Path], Set[Path], Set[Path], Set[Path], Set[Path]]:
    """Search source_dir and it's subdirectories for file of the type *.c, test_*.c, *.h, *.cat"""
    source_dir: Path = Path(source_dir)

    all_source_files = set(source_dir.glob("**/*.c"))
    test_source_files = set(
        x for x in all_source_files if x.stem.lower().startswith(test_prefix))
    source_files = all_source_files.difference(test_source_files)

    headers_files = set(source_dir.glob("**/*.h"))
    catalog_files = set(source_dir.glob("**/*.cat"))

    # making all the path relative
    source_files, test_source_files, headers_files, catalog_files = (
        set(p.relative_to(source_dir) for p in paths)
        for paths in (source_files, test_source_files, headers_files, catalog_files)
    )

    # collecting interesting directories
    directories = set(p.parent for p in chain(
        source_files, test_source_files, headers_files, catalog_files))

    return (source_files, test_source_files, headers_files, catalog_files, directories)


def make_compile_rule(source: Path, source_dir: Path) -> str:
    """Create a compile rule for source"""
    # first we get all the includes
    p = subprocess.Popen(["gcc", "-MM", "-MG", str(source_dir / source)],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    output, output_err = p.communicate()

    if output_err:
        print(f"Error while reading includes of {source}", file=stderr)
        print(output_err.decode("utf-8"), file=stderr)
        exit(1)

    files = [Path(p) for p in output.decode("utf-8").split(":",
                                                           maxsplit=1)[1].replace("\\\n", "").split()]

    catalog_files = [(source.parent / p)
                     for p in files if p.name.endswith(".cat.h")]
    catalog_dirs = set(p.parent for p in catalog_files)

    main_file = (source_dir / source).resolve().relative_to(source_dir.absolute())
    other_files = set(p.resolve().relative_to(source_dir.absolute()) for p in files if not p.name.endswith(".cat.h"))
    other_files.discard(main_file)
    
    # sorting to guarantee repeatability
    catalog_files, catalog_dirs, other_files = (
        sorted(paths)
        for paths in (catalog_files, catalog_dirs, other_files)
    )

    rule = f"""$(BUILD_DIR)/{source.with_suffix(".o")}: $(SOURCE_DIR)/{str(main_file)} \\
    {" ".join(f"$(SOURCE_DIR)/{str(p)}" for p in other_files)} \\
    {" ".join(f"$(BUILD_DIR)/{str(p)}" for p in catalog_files)} | \\
    $(dir $(BUILD_DIR)/{source.with_suffix(".o")})
\t$(CC) $(CFLAGS) {" ".join(f"-I$(BUILD_DIR)/{str(p)}" for p in catalog_dirs)} -c $< -o $@"""

    return rule


def get_argparser() -> ArgumentParser:
    """Prepare a argument parser for cli invocation"""
    parser = ArgumentParser(description=__doc__)

    # TODO: change all argumets from - prefix to -- prefix

    parser.add_argument("outputfile", nargs="?", type=str, default="Makefile",
                        help="The output Makefile. If absent defaults to \"Makefile\"")
    parser.add_argument("-mskel", nargs="?", type=FileType("r"), default=open("Makefile.skel", "r"),
                        help="The input Makefile skeleton. If absent defaults to \"Makefile.skel\"")

    for par_name, (par_default, par_descr) in PARAMETER.items():
        parser.add_argument(f"-{par_name}", type=str,
                            default=par_default, help=par_descr)

    parser.add_argument("-gendiffs", metavar="DIFFS.HTML", type=FileType("w"),
                        help="If a new makefile is written, the differences are outputted to DIFFS.HTML")
    parser.add_argument("-force", "-f",  action="store_true", default=False,
                        help="If set the makefile is regenerated even if equal to the old one")

    return parser


def need_to_update(old_makefile: str, new_makefile: str) -> bool:
    """Check if we need to update the makefile"""

    # splitting in logical lines
    old_makefile_lines: List[str] = ["\\"]
    for line in old_makefile.splitlines():
        if old_makefile_lines[-1].endswith("\\"):
            old_makefile_lines[-1] = old_makefile_lines[-1][:-1] + line
        else:
            old_makefile_lines.append(line)

    new_makefile_lines: List[str] = ["\\"]
    for line in new_makefile.splitlines():
        if new_makefile_lines[-1].endswith("\\"):
            new_makefile_lines[-1] = new_makefile_lines[-1][:-1] + line
        else:
            new_makefile_lines.append(line)

    # deleting comments (only full line ones) and blank lines
    old_makefile_lines = [
        line for line in old_makefile_lines if line.strip() and not line.strip().startswith("#")]
    new_makefile_lines = [
        line for line in new_makefile_lines if line.strip() and not line.strip().startswith("#")]

    return old_makefile_lines != new_makefile_lines


def main(argv):
    parsed_args = get_argparser().parse_args(argv[1:])

    source_files, test_source_files, headers_files, catalog_files, directories = examine_source_tree(
        parsed_args.source_dir, parsed_args.test_prefix)

    # remove main from source files
    source_files.discard(Path(parsed_args.main_name))

    # sorting all sets. This guarantee repeatability
    source_files, test_source_files, headers_files, catalog_files, directories = (
        sorted(paths)
        for paths in (source_files, test_source_files, headers_files, catalog_files, directories)
    )

    parameters = {name: vars(parsed_args)[name] for name in PARAMETER}
    parameters["date"] = datetime.now()
    parameters["configure_name"] = argv[0]
    parameters["makefile_skel"] = parsed_args.mskel.name

    parameters["sources"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in source_files)
    parameters["test_sources"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in test_source_files)

    parameters["objects"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.o'))}" for p in source_files)
    parameters["main_obj"] = f"$(BUILD_DIR)/{str(Path(parsed_args.main_name).with_suffix('.o'))}"
    parameters["test_objects"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.o'))}" for p in test_source_files)
    parameters["test_main_obj"] = f"$(BUILD_DIR)/{str(Path(parsed_args.test_main_name).with_suffix('.o'))}"

    parameters["catalog_files"] = " ".join(
        f"$(SOURCE_DIR)/{str(p)}" for p in catalog_files)
    parameters["catalog_header"] = " ".join(
        f"$(BUILD_DIR)/{str(p.with_suffix('.cat.h'))}" for p in catalog_files)

    parameters["compile_rules"] = make_compile_rule(Path(parsed_args.main_name), Path(parsed_args.source_dir))+"\n\n" + "\n\n".join(
        make_compile_rule(p, Path(parsed_args.source_dir)) for p in source_files)
    parameters["compile_test_rules"] = "\n\n".join(
        make_compile_rule(p, Path(parsed_args.source_dir)) for p in test_source_files)
    parameters["catalog_rules"] = "\n\n".join(
        CATALOG_RULE.format(cat_name=str(p), cat_header_name=str(p.with_suffix(".cat.h"))) for p in catalog_files)
    parameters["directory_rules"] = "\n\n".join(
        DIRECTORY_RULE.format(dirname=str(p)) for p in directories)

    new_makefile = parsed_args.mskel.read().format(**parameters)

    if not parsed_args.force and parsed_args.outputfile.strip() != "-" and Path(parsed_args.outputfile).is_file():
        with open(parsed_args.outputfile, "r") as old_makefile_f:
            old_makefile = old_makefile_f.read()
            if parsed_args.gendiffs is not None:
                print(
                    HtmlDiff().make_file(old_makefile.splitlines(), new_makefile.splitlines(),
                                         fromdesc=f"Old {parsed_args.outputfile}", todesc=f"New {parsed_args.outputfile}",
                                         context=True),
                    file=parsed_args.gendiffs)
            if not need_to_update(old_makefile, new_makefile):
                print("Makefile is up-to-date")
                return  # avoid updating the file, so it won't regenerate all recipes

    if parsed_args.outputfile.strip() != "-":
        with open(parsed_args.outputfile, "w") as makefile:
            makefile.write(new_makefile)
    else:
        stdout.write(new_makefile)


if __name__ == "__main__":
    from sys import argv
    main(argv)
